from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from django.db import transaction
from apps.parents.models import Parent
from apps.applicants.models import Applicant
from apps.students.models import Student
from apps.accounts.models import UserProfile, ParentProfile, StudentProfile
from apps.portal.models import PortalNotification, PortalActivity
import re


class Command(BaseCommand):
    help = 'Clean up test data generated by generate_test_data command'

    def add_arguments(self, parser):
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force deletion without confirmation',
        )

    def handle(self, *args, **kwargs):
        # Email pattern for test data
        test_email_pattern = r'^(parent|student)\d+@test\.com$'

        try:
            # Count records to be deleted
            test_users = User.objects.filter(email__regex=test_email_pattern)
            test_parents = Parent.objects.filter(
                email__regex=test_email_pattern)
            test_students = Student.objects.filter(
                email__regex=test_email_pattern)
            test_applicants = Applicant.objects.filter(
                email__regex=test_email_pattern)

            total_count = {
                'Users': test_users.count(),
                'Parents': test_parents.count(),
                'Students': test_students.count(),
                'Applicants': test_applicants.count(),
            }

            # Show what will be deleted
            self.stdout.write('\nThe following test records will be deleted:')
            for model, count in total_count.items():
                self.stdout.write(f'{model}: {count}')

            # Get confirmation unless --force is used
            if not kwargs['force']:
                confirm = input(
                    '\nAre you sure you want to delete these records? (yes/no): ')
                if confirm.lower() != 'yes':
                    self.stdout.write('Cleanup cancelled.')
                    return

            with transaction.atomic():
                # Delete portal activities and notifications first
                self.stdout.write(
                    'Deleting portal activities and notifications...')
                PortalActivity.objects.filter(
                    user__email__regex=test_email_pattern
                ).delete()
                PortalNotification.objects.filter(
                    user__email__regex=test_email_pattern
                ).delete()

                # Delete profiles
                self.stdout.write('Deleting user profiles...')
                StudentProfile.objects.filter(
                    user_profile__user__email__regex=test_email_pattern
                ).delete()
                ParentProfile.objects.filter(
                    user_profile__user__email__regex=test_email_pattern
                ).delete()
                UserProfile.objects.filter(
                    user__email__regex=test_email_pattern
                ).delete()

                # Delete test users
                self.stdout.write('Deleting test users...')
                test_users.delete()

                # Delete test data from main models
                self.stdout.write('Deleting test students...')
                test_students.delete()

                self.stdout.write('Deleting test applicants...')
                test_applicants.delete()

                self.stdout.write('Deleting test parents...')
                test_parents.delete()

                # Final confirmation
                self.stdout.write(self.style.SUCCESS(
                    '\nSuccessfully deleted all test data:'
                ))
                for model, count in total_count.items():
                    self.stdout.write(f'- {model}: {count}')

        except Exception as e:
            self.stdout.write(
                self.style.ERROR(
                    f'\nError while cleaning up test data: {str(e)}')
            )
            raise e

    def get_test_emails(self):
        """Helper method to get list of test emails"""
        test_emails = []
        with open('test_data_emails.txt', 'r') as f:
            test_emails = f.read().splitlines()
        return test_emails
